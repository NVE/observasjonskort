import { BoundingBox } from '../global/interfaces/svggeom';
export declare class MPoint {
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    toString(): string;
    toFixed(n: number): string;
    fromString(ptstr: string): boolean;
    clone(): MPoint;
    multNumber(a: number): MPoint;
    multMPoint(coeff: MPoint): MPoint;
    multMatrix(a: Array<Array<number>>): MPoint;
    addMPoint(pt: MPoint): MPoint;
    substractMPoint(pt: MPoint): MPoint;
    middleMPoint(pt: MPoint): MPoint;
    distance(pt: MPoint): MPoint;
    dotProduct(ptEnd: MPoint, pt: MPoint): number;
    isMPointOnLine(ptEnd: MPoint, pt: MPoint): boolean;
    scalarDistance(pt: MPoint): number;
    atDistanceMPoint(pt: MPoint, distance: number): MPoint;
}
export declare class CubicBezierCurve {
    P1: MPoint;
    P2: MPoint;
    P3: MPoint;
    P4: MPoint;
    constructor(p1?: MPoint, p2?: MPoint, p3?: MPoint, p4?: MPoint);
    onCurveMPointAtTpos(t: number): MPoint;
    getSegmentBox(pt0: MPoint, pt1: MPoint, pt2: MPoint, pt3: MPoint): {
        bBox: BoundingBox;
        bMPoints: Array<MPoint>;
        bTValues: Array<number>;
    };
}
export declare class Matrix {
    matrix: Array<Array<number>> | Array<number>;
    private _size;
    constructor(msize?: Array<number> | number);
    setSize(arr: Array<number> | number): void;
    getSize(): Array<number> | number;
    zeros(): void;
    identity(): void;
    clone(): Matrix;
    circularPermuteRow(opt: any): void;
    flipRow(): void;
    multiply(bMat: Matrix): Matrix;
    multiplyByVectorMPoints(vMPoints: Array<MPoint>): Array<MPoint>;
}
