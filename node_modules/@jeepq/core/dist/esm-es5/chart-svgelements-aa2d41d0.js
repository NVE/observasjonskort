var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { g as getBoundingClientRect } from './common-61073bba.js';
var windowSize = function (window) {
    return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight
    };
};
var xmlns = "http://www.w3.org/2000/svg";
var createSVGElement = function (eltype, parent) {
    var svgEl = document.createElementNS(xmlns, eltype);
    if (parent)
        parent.appendChild(svgEl);
    return svgEl;
};
var createText = function (g, text, pos, options) {
    var opt = getSVGOptions(options);
    var textEl = createSVGElement("text", g);
    textEl.setAttributeNS(null, "x", pos.x.toString());
    textEl.setAttributeNS(null, "y", pos.y.toString());
    textEl.textContent = text;
    elementSVGOptions(opt, textEl, 'text');
    return textEl;
};
var updateText = function (svg, id, anchor, pos) {
    var textEl = svg.querySelector('#' + id);
    textEl.setAttributeNS(null, "x", pos.x.toString());
    textEl.setAttributeNS(null, "y", pos.y.toString());
    textEl.setAttributeNS(null, "text-anchor", anchor);
    return textEl;
};
var createLine = function (g, pos1, pos2, options) {
    var opt = getSVGOptions(options);
    var lineEl = createSVGElement("line", g);
    lineEl.setAttributeNS(null, "x1", pos1.x.toString());
    lineEl.setAttributeNS(null, "y1", pos1.y.toString());
    lineEl.setAttributeNS(null, "x2", pos2.x.toString());
    lineEl.setAttributeNS(null, "y2", pos2.y.toString());
    elementSVGOptions(opt, lineEl);
    return lineEl;
};
var updateLine = function (svg, id, pos1, pos2) {
    var lineEl = svg.querySelector('#' + id);
    lineEl.setAttributeNS(null, "x1", pos1.x.toString());
    lineEl.setAttributeNS(null, "y1", pos1.y.toString());
    lineEl.setAttributeNS(null, "x2", pos2.x.toString());
    lineEl.setAttributeNS(null, "y2", pos2.y.toString());
    return lineEl;
};
var createRect = function (g, rect, options) {
    var opt = getSVGOptions(options);
    var rectEl = createSVGElement("rect", g);
    rectEl.setAttributeNS(null, "x", rect.left.toString());
    rectEl.setAttributeNS(null, "y", rect.top.toString());
    rectEl.setAttributeNS(null, "width", rect.width.toString());
    rectEl.setAttributeNS(null, "height", rect.height.toString());
    elementSVGOptions(opt, rectEl);
    return rectEl;
};
var updateRect = function (svg, id, rect) {
    var rectEl = svg.querySelector('#' + id);
    rectEl.setAttributeNS(null, "x", rect.left.toString());
    rectEl.setAttributeNS(null, "y", rect.top.toString());
    rectEl.setAttributeNS(null, "width", rect.width.toString());
    rectEl.setAttributeNS(null, "height", rect.height.toString());
    return rectEl;
};
var createCircle = function (g, pos, radius, options) {
    var opt = getSVGOptions(options);
    var circleEl = createSVGElement('circle', g);
    circleEl.setAttributeNS(null, "cx", pos.x.toString());
    circleEl.setAttributeNS(null, "cy", pos.y.toString());
    circleEl.setAttributeNS(null, "r", radius.toString());
    elementSVGOptions(opt, circleEl);
    return circleEl;
};
var updateCircle = function (svg, id, pos, radius) {
    var circleEl = svg.querySelector('#' + id);
    circleEl.setAttributeNS(null, "cx", pos.x.toString());
    circleEl.setAttributeNS(null, "cy", pos.y.toString());
    circleEl.setAttributeNS(null, "r", radius.toString());
    return circleEl;
};
var createPolyline = function (g, points, options) {
    var opt = getSVGOptions(options);
    var plineEl = createSVGElement('polyline', g);
    plineEl.setAttributeNS(null, "points", points);
    elementSVGOptions(opt, plineEl);
    return plineEl;
};
var updatePolyline = function (svg, id, points) {
    var plineEl = svg.querySelector('#' + id);
    plineEl.setAttributeNS(null, "points", points);
    return plineEl;
};
var createMarker = function (defs, d, opt) {
    var g = createSVGElement('g', defs);
    g.setAttribute("id", opt.id);
    g.setAttribute('viewbox', opt.viewbox);
    var path = createSVGElement('path', g);
    path.setAttribute('d', d);
};
var createAnimation = function (el, anim) {
    var animEl = createSVGElement('animate', el);
    animEl.setAttributeNS(null, "attributeName", anim.attributeName);
    animEl.setAttributeNS(null, "from", anim.from);
    animEl.setAttributeNS(null, "to", anim.to);
    animEl.setAttributeNS(null, "dur", anim.dur);
    animEl.setAttributeNS(null, "fill", anim.fill);
    return animEl;
};
function createColumnLabel(svg, colbb, label, index, color, pt, borderBB, options) {
    var opt = getSVGOptions(options);
    //measure the label text size  
    var textEl = createSVGElement("text", svg);
    textEl.setAttributeNS(null, 'x', "0");
    textEl.setAttributeNS(null, 'y', "0");
    elementSVGOptions(opt, textEl, 'text');
    textEl.textContent = label;
    var bb = textEl.getBoundingClientRect();
    svg.removeChild(textEl);
    // create a group
    var gEl = createSVGElement("g", svg);
    gEl.setAttributeNS(null, 'id', "columnchart-label-value");
    // text dimensions
    var rwidth = bb.width + 10;
    var rheight = bb.height + 10;
    //    let xpos: number = index > 1 ? colbb.left + Math.floor(0.1*colbb.width) - rwidth : colbb.left + colbb.width - Math.floor(0.1*colbb.width);
    var xpos = index > 1 ? colbb.right - borderBB.left - Math.floor(0.1 * colbb.width) - rwidth : colbb.left - borderBB.left + Math.floor(0.1 * colbb.width);
    var ypos = Math.floor(pt.y - rheight - 15);
    var rectEl = createSVGElement("rect", gEl);
    rectEl.setAttributeNS(null, 'x', xpos.toString());
    rectEl.setAttributeNS(null, 'y', ypos.toString());
    rectEl.setAttributeNS(null, 'width', rwidth.toString());
    rectEl.setAttributeNS(null, 'height', rheight.toString());
    rectEl.setAttributeNS(null, 'stroke', color);
    rectEl.setAttributeNS(null, 'fill', '#ffffff');
    rectEl.setAttributeNS(null, 'fill-opacity', '0.85');
    textEl = createSVGElement("text", gEl);
    //define xtext
    var xtext = xpos + (bb.width + 10) / 2;
    var ytext = ypos + 3 * (bb.height + 10) / 4;
    textEl.setAttributeNS(null, 'x', xtext.toString());
    textEl.setAttributeNS(null, 'y', ytext.toString());
    elementSVGOptions(opt, textEl, 'text');
    textEl.textContent = label;
}
var createLineLabel = function (svg, label, pt, color, options) { return __awaiter(void 0, void 0, void 0, function () {
    var opt, textBB, lbPos, id;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                opt = getSVGOptions(options);
                return [4 /*yield*/, measureText(svg, label, opt)];
            case 1:
                textBB = _a.sent();
                lbPos = {};
                lbPos.width = textBB.width + 10;
                lbPos.height = textBB.height + 10;
                lbPos.left = pt.point.x - lbPos.width - 10 > 0 ? Math.floor(pt.point.x - lbPos.width - 10) : Math.floor(pt.point.x + 10);
                lbPos.top = Math.floor(pt.point.y - lbPos.height - 10);
                id = "linechart-label-value";
                // create the label
                createLabel(svg, id, label, lbPos, color, opt);
                return [2 /*return*/];
        }
    });
}); };
var createLabel = function (svg, id, label, lbPos, color, opt) {
    // create a group
    var gEl = createSVGElement('g', svg);
    gEl.setAttributeNS(null, 'id', id);
    var rectEl = createSVGElement('rect', gEl);
    rectEl.setAttributeNS(null, 'x', lbPos.left.toString());
    rectEl.setAttributeNS(null, 'y', lbPos.top.toString());
    rectEl.setAttributeNS(null, 'width', lbPos.width.toString());
    rectEl.setAttributeNS(null, 'height', lbPos.height.toString());
    rectEl.setAttributeNS(null, 'stroke', color);
    rectEl.setAttributeNS(null, 'fill', '#ffffff');
    rectEl.setAttributeNS(null, 'fill-opacity', '0.85');
    var textEl = createSVGElement('text', gEl);
    //define xtext
    var xtext = lbPos.left + lbPos.width / 2;
    var ytext = lbPos.top + 3 * lbPos.height / 4;
    textEl.setAttributeNS(null, 'x', xtext.toString());
    textEl.setAttributeNS(null, 'y', ytext.toString());
    elementSVGOptions(opt, textEl, 'text');
    textEl.textContent = label;
};
var createLegendLines = function (gEl, names, colors, thicknesses, data, winWidth, ypos, optLg) {
    var itemsPlaced = 0;
    var pos1;
    var pos2;
    var pos3;
    var optLine;
    var yLine = ypos;
    for (var i = 0; i < data.nLines; i++) {
        for (var j = 0; j < data.nItems; j++) {
            if (j === 0) {
                pos1 = { x: winWidth / 2 - data.lineLength / 2, y: yLine };
            }
            else {
                pos1 = { x: pos1.x + data.bBoxItem.width + 20, y: pos1.y };
            }
            pos2 = { x: pos1.x + 15, y: pos1.y };
            pos3 = { x: pos1.x + 20, y: pos1.y };
            optLine = { stroke: colors[itemsPlaced], strokeWidth: thicknesses[itemsPlaced].toString() };
            createLegendItem(gEl, pos1, pos2, optLine, names[itemsPlaced], pos3, optLg);
            itemsPlaced += 1;
            if (itemsPlaced >= names.length)
                break;
        }
        yLine += data.bBoxItem.height + 2;
    }
};
var measureLegend = function (svg, winWidth, names, colors, thicknesses, optLg) {
    // look for  the max length names
    var name = maxLegend(names);
    var dLegend = {};
    // measure legend item
    dLegend.bBoxItem = measureLegendItem(svg, name, optLg);
    // calculate number of legend items per legend line
    dLegend.nItems = Math.floor((winWidth - 20) / (dLegend.bBoxItem.width + 20));
    if (dLegend.nItems > names.length)
        dLegend.nItems = names.length;
    // calculate legend lines length
    dLegend.lineLength = dLegend.nItems * (dLegend.bBoxItem.width + 20);
    // calculate number of legend lines
    dLegend.nLines = Math.ceil(names.length / dLegend.nItems);
    // create legend lines
    var ypos = 10;
    var gEl = createSVGElement('g', svg);
    createLegendLines(gEl, names, colors, thicknesses, dLegend, winWidth, ypos, optLg);
    // calculate the legend lines BoundingClientRect
    dLegend.bBox = gEl.getBoundingClientRect();
    // remove the legend lines   
    svg.removeChild(gEl);
    return dLegend;
};
var measureLegendItem = function (svg, label, opt) {
    var optLine = {
        stroke: '#000000'
    };
    var pos1 = { x: 0, y: 0 };
    var pos2 = { x: 15, y: 0 };
    var pos3 = { x: 20, y: 0 };
    var gEl = createSVGElement('g', svg);
    createLegendItem(gEl, pos1, pos2, optLine, label, pos3, opt);
    var bb = gEl.getBoundingClientRect();
    svg.removeChild(gEl);
    return bb;
};
var createLegendItem = function (g, pos1, pos2, optLine, label, pos3, optText) {
    createLine(g, pos1, pos2, optLine);
    createText(g, label, pos3, optText);
};
var measureText = function (svg, label, opt, mockFunc) { return __awaiter(void 0, void 0, void 0, function () {
    var getBCR, textEl, bb;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                getBCR = mockFunc ? mockFunc : getBoundingClientRect;
                textEl = createSVGElement('text', svg);
                textEl.setAttributeNS(null, 'x', "0");
                textEl.setAttributeNS(null, 'y', "0");
                elementSVGOptions(opt, textEl, 'text');
                textEl.textContent = label;
                return [4 /*yield*/, getBCR(textEl)];
            case 1:
                bb = _a.sent();
                svg.removeChild(textEl);
                return [2 /*return*/, bb];
        }
    });
}); };
var getSVGOptions = function (options) {
    var anchor = ["start", "middle", "end"];
    var linejoin = ["miter", "round", "bevel"];
    var linecap = ["butt", "round", "square"];
    var ret = {};
    var opt = options ? options : {};
    ret.id = opt.id ? opt.id : null;
    ret.fontFamily = opt.fontFamily ? opt.fontFamily : "Verdana";
    ret.fontSize = opt.fontSize ? opt.fontSize : "10px";
    ret.fill = opt.fill ? opt.fill : null;
    ret.fillOpacity = opt.fillOpacity ? opt.fillOpacity : null;
    ret.anchor = anchor.indexOf(opt.anchor) > -1 ? opt.anchor : null;
    ret.stroke = opt.stroke ? opt.stroke : null;
    ret.strokeWidth = opt.strokeWidth ? opt.strokeWidth : null;
    ret.strokeOpacity = opt.strokeOpacity ? opt.strokeOpacity : null;
    ret.strokeLinejoin = linejoin.indexOf(opt.strokeLinejoin) > -1 ? opt.strokeLinejoin : null;
    ret.strokeLinecap = linecap.indexOf(opt.strokeLinecap) > -1 ? opt.strokeLinecap : null;
    ret.strokeMiterlimit = opt.strokeMiterlimit ? opt.strokeMiterlimit : null;
    ret.strokeDasharray = opt.strokeDasharray ? opt.strokeDasharray : null;
    ret.strokeDashoffset = opt.strokeDashoffset ? opt.strokeDashoffset : null;
    return ret;
};
var elementSVGOptions = function (opt, el, elType) {
    var type = elType ? elType : null;
    if (opt.id !== null)
        el.setAttributeNS(null, "id", opt.id);
    if (type === 'text')
        el.setAttributeNS(null, "font-family", opt.fontFamily);
    if (type === 'text')
        el.setAttributeNS(null, "font-size", opt.fontSize);
    if (type === 'text' && opt.anchor !== null)
        el.setAttributeNS(null, "text-anchor", opt.anchor);
    if (opt.fill !== null)
        el.setAttributeNS(null, "fill", opt.fill);
    if (opt.fillOpacity !== null)
        el.setAttributeNS(null, "fill-opacity", opt.fillOpacity);
    if (opt.stroke !== null)
        el.setAttributeNS(null, "stroke", opt.stroke);
    if (opt.strokeWidth !== null)
        el.setAttributeNS(null, "stroke-width", opt.strokeWidth);
    if (opt.strokeOpacity !== null)
        el.setAttributeNS(null, "stroke-opacity", opt.strokeOpacity);
    if (opt.strokeLinejoin !== null)
        el.setAttributeNS(null, "stroke-linejoin", opt.strokeLinejoin);
    if (opt.strokeLinecap !== null)
        el.setAttributeNS(null, "stroke-linecap", opt.strokeLinecap);
    if (opt.strokeMiterlimit !== null)
        el.setAttributeNS(null, "stroke-miterlimit", opt.strokeMiterlimit);
    if (opt.strokeDasharray !== null)
        el.setAttributeNS(null, "stroke-dasharray", opt.strokeDasharray);
    if (opt.strokeDashoffset !== null)
        el.setAttributeNS(null, "stroke-dashoffset", opt.strokeDashoffset);
};
var textScale = function (text, window, padding) {
    if (text < window - 2 * padding)
        return 1;
    return Number(((window - 2 * padding) / text).toFixed(4));
};
var axisNiceNumber = function (x, round, min) {
    var exp = Math.floor(Math.log(x) / Math.LN10);
    var f = x / Math.pow(10, exp);
    var nf;
    if (round) {
        if (f < 2)
            nf = 0.5;
        else if (f < 5)
            nf = 1;
        else
            nf = 2;
    }
    else {
        if (f < 1.5)
            nf = 1.5;
        else if (f < 2)
            nf = 2;
        else if (f < 3)
            nf = 3;
        else if (f < 4)
            nf = 4;
        else if (f < 5)
            nf = 5;
        else if (f < 6)
            nf = 6;
        else if (f < 7)
            nf = 7;
        else
            nf = 10;
        if (min)
            nf -= 1;
    }
    return Number((nf * Math.pow(10, exp)).toFixed(20));
};
var axisGetNumber = function (x, interval, round, min) {
    if (interval === 0)
        return axisNiceNumber(x, round, min);
    if (round) {
        return interval;
    }
    else {
        if (min) {
            return interval * Math.floor(x / interval);
        }
        else {
            return interval * (Math.floor(x / interval) + 1);
        }
    }
};
var axisMaxArrayAttribute = function (arr, attr) {
    var max;
    if (arr[0].dataPoints[0][attr] != null) {
        for (var i = 0; i < arr.length; i++) {
            for (var j = 0; j < arr[i].dataPoints.length; j++) {
                if (!max || parseInt(arr[i].dataPoints[j][attr]) > parseInt(max[attr]))
                    max = arr[i].dataPoints[j];
            }
        }
        return max;
    }
    else {
        return null;
    }
};
var axisMinArrayAttribute = function (arr, attr) {
    var min;
    if (arr[0].dataPoints[0][attr] != null) {
        for (var i = 0; i < arr.length; i++) {
            for (var j = 0; j < arr[i].dataPoints.length; j++) {
                if (!min || parseInt(arr[i].dataPoints[j][attr]) < parseInt(min[attr]))
                    min = arr[i].dataPoints[j];
            }
        }
        return min;
    }
    else {
        return null;
    }
};
var axisMaxArrayLabel = function (arr, attr) {
    var max = null;
    if (arr[0].dataPoints[0][attr] != null) {
        for (var i = 0; i < arr.length; i++) {
            for (var j = 0; j < arr[i].dataPoints.length; j++) {
                if (!max || arr[i].dataPoints[j][attr].length > max[attr].length)
                    max = arr[i].dataPoints[j];
            }
        }
        return max;
    }
    else {
        return null;
    }
};
var maxLegend = function (arr) {
    var max = null;
    for (var i = 0; i < arr.length; i++) {
        if (!max || arr[i].length > max.length) {
            max = arr[i];
        }
    }
    return max;
};
var axisRange = function (arr, axis, _interval, _zero) {
    var interval = _interval ? _interval : 0;
    var zero = _zero ? _zero : false;
    var lenAxis = {};
    if (axis === "label" && arr[0].dataPoints[0].label) {
        if (arr.length > 1 || arr[0].dataPoints.length > 1) {
            lenAxis.label = axisMaxArrayLabel(arr, "label").label;
        }
        else {
            lenAxis.label = arr[0].dataPoints[0].label;
        }
        lenAxis.type = 'string';
        if (interval != 0)
            lenAxis.interval = interval;
    }
    else if (axis === "x" && typeof arr[0].dataPoints[0].x === 'string') {
        if (arr.length > 1 || arr[0].dataPoints.length > 1) {
            lenAxis.label = axisMaxArrayLabel(arr, "x").x;
        }
        else {
            lenAxis.label = arr[0].dataPoints[0].x;
        }
        lenAxis.type = 'string';
        if (interval != 0)
            lenAxis.interval = interval;
    }
    else if ((axis === "x" && typeof arr[0].dataPoints[0].x === 'number') || axis === "y") {
        var maxAxis = void 0;
        var minAxis = void 0;
        lenAxis.type = 'number';
        if (axis === "y") {
            maxAxis = axisMaxArrayAttribute(arr, axis).y;
            minAxis = axisMinArrayAttribute(arr, axis).y;
        }
        if (axis === "x") {
            if (arr.length > 1 || arr[0].dataPoints.length > 1) {
                maxAxis = axisMaxArrayAttribute(arr, axis).x;
                minAxis = axisMinArrayAttribute(arr, axis).x;
            }
            else {
                maxAxis = arr[0].dataPoints[0].x + interval / 2;
                minAxis = arr[0].dataPoints[0].x - interval / 2;
            }
        }
        if (maxAxis > 0 && minAxis >= 0) {
            lenAxis.top = axisGetNumber(maxAxis, interval, false, false);
            if (zero) {
                lenAxis.bottom = 0;
                lenAxis.interval = axisGetNumber(maxAxis, interval, true, false);
            }
            else {
                lenAxis.bottom = axisGetNumber(minAxis, interval, false, true);
                lenAxis.interval = axisGetNumber(maxAxis - minAxis, interval, true, false);
            }
            lenAxis.length = lenAxis.top - lenAxis.bottom;
        }
        if (maxAxis > 0 && minAxis < 0) {
            lenAxis.top = axisGetNumber(maxAxis, interval, false, false);
            lenAxis.interval = axisGetNumber(maxAxis, interval, true, false);
            lenAxis.bottom = -Math.ceil(-minAxis / lenAxis.interval) * lenAxis.interval;
            lenAxis.length = lenAxis.top - lenAxis.bottom;
        }
        if (maxAxis <= 0) {
            if (zero) {
                lenAxis.top = 0;
                lenAxis.interval = -axisGetNumber(-minAxis, interval, true, false);
            }
            else {
                lenAxis.top = -axisGetNumber(-maxAxis, interval, false, true);
                lenAxis.interval = -axisGetNumber(-(minAxis - maxAxis), interval, true, false);
            }
            lenAxis.bottom = -axisGetNumber(-minAxis, interval, false, false);
            lenAxis.length = lenAxis.top - lenAxis.bottom;
        }
    }
    return lenAxis;
};
var axisConvertY = function (cRect, aLength, s) {
    return cRect.top + (aLength.top - s) * (cRect.height) / aLength.length;
};
var axisConvertX = function (cRect, aLength, s) {
    return cRect.left + (s - aLength.bottom) * (cRect.width) / aLength.length;
};
var removeChilds = function (el) {
    while (el.firstChild) {
        el.removeChild(el.firstChild);
    }
};
var getNearest = function (values, pt) {
    var value = null;
    var min = 1.0e20;
    for (var l = 0; l < values.length; l++) {
        for (var i = 0; i < values[l].length; i++) {
            var dist = scalarDistance(values[l][i], pt);
            if (dist < min) {
                value = { line: l, index: i, point: values[l][i] };
                min = dist;
            }
        }
    }
    return value;
};
var scalarDistance = function (val, pt) {
    return Math.sqrt((val.x - pt.x) * (val.x - pt.x) + (val.y - pt.y) * (val.y - pt.y));
};
var getTotalLength = function (arr) {
    var length = 0;
    for (var i = 1; i < arr.length; i++) {
        length += scalarDistance(arr[i], arr[i - 1]);
    }
    return length;
};
/*
export const numberOfXlines = (arr:Array<DataSet>,type:string): InfoDataSets => {
    let retValue: InfoDataSets = {};
    let maxPoints: number  = null;
    let nDataSet: number = null;
    let onePoints: Array<{
        nDataSet?: number;
        indexOnePoint?: number;
    }> = [];

    for (let i:number = 0;i<arr.length;i++){
        if (arr[i].dataPoints.length === 1 ) onePoints.push({'nDataSet': i});
        if (!maxPoints || arr[i].dataPoints.length > maxPoints) {
            maxPoints = arr[i].dataPoints.length;
            nDataSet = i;
        }
    }
    retValue.maxPoints = maxPoints;
    retValue.nDataSet = nDataSet;
    retValue.type = type;
    retValue.onePoints = onePoints;
    return retValue;
}
*/
var checkDataSetsValidity = function (arr, axisType) {
    var retValue = { "dataSets": null, message: null };
    var type = typeof arr[0].dataPoints[0][axisType[0]];
    var curType = { "type": type, "axType": axisType[0] };
    // dataPoints should be in ['label','x','y']
    for (var i = 0; i < arr.length; i++) {
        var tArr = arr[i].dataPoints.map(function (item) { return Object.keys(item).every(function (v) { return axisType.indexOf(v) !== -1; }); }, axisType);
        if (tArr.indexOf(false) != -1) {
            retValue = { "dataSets": null,
                "message": "Non consistent key in dataPoints key in [" + axisType + "]" };
            break;
        }
    }
    if (retValue.message != null)
        return retValue;
    // 'x' or 'label' should be of consistent type
    for (var i = 0; i < arr.length; i++) {
        var typeArray = arr[i].dataPoints.map(function (item) { return typeof item[curType.axType] === curType.type ? true : false; }, curType);
        if (typeArray.indexOf(false) != -1) {
            retValue = { "dataSets": null,
                "message": "Non consistent " + axisType[0] + " type in dataPoints" };
            break;
        }
    }
    if (retValue.message != null)
        return retValue;
    // 'label' should be of type string
    if (axisType[0] === 'label' && type != 'string')
        retValue = { "dataSets": null,
            "message": "DataPoints label must be of type string" };
    if (retValue.message != null)
        return retValue;
    // type string multiple lines must have dataPoints of same length
    if (type === 'string') {
        var length_1 = arr[0].dataPoints.length;
        var lArr = arr.map(function (item) { return item.dataPoints.length === length_1 ? true : false; }, length_1);
        if (lArr.indexOf(false) != -1) {
            retValue = { "dataSets": null,
                "message": "DataSet DataPoints having 'label' or 'x' of type string must be of same length" };
        }
        if (retValue.message != null)
            return retValue;
    }
    // 'x' type string or label
    /*    let info: InfoDataSets = numberOfXlines(arr,type);
        // for dataSets of type string with different lengths the x given
        // should be contained in the x of the maximum length dataSets
        if(type === 'string') {
            let maxString: Array<String> = arr[info.nDataSet].dataPoints.map(item => {return item.x;});
    
            if(info.onePoints.length > 0) {
                for (let i:number = 0;i<info.onePoints.length;i++) {
                    info.onePoints[i].indexOnePoint = maxString.indexOf(arr[info.onePoints[i].nDataSet].dataPoints[0].x);
                }
                let check: Array<number> = info.onePoints.map(item => {return item.indexOnePoint;});
    
                if(check.indexOf(-1) === -1) {
                    // Ok
                    retValue = {"dataSets": arr,"infoDataSet": info};
                }
            } else {
                let checkB: Array<Boolean> = [];
                for (let i:number = 1;i<arr.length;i++) {
                    let line: Array<String> = arr[i].dataPoints.map(item => {return item.x;});
                    checkB.push(JSON.stringify(maxString)==JSON.stringify(line));
                }
                if( checkB.indexOf(false) === -1 ) {
                    // Ok
                    retValue = {"dataSets": arr,"infoDataSet": info};
                }
            }
        }
        if(type === 'number') {
            retValue = {"dataSets": arr};
        }
       
        retValue = {"dataSets": arr};
        */
    return { "dataSets": arr };
};
export { createText as a, axisRange as b, createSVGElement as c, createLine as d, updateLine as e, createRect as f, updateRect as g, createAnimation as h, createColumnLabel as i, axisConvertY as j, checkDataSetsValidity as k, createMarker as l, measureLegend as m, createLegendLines as n, createPolyline as o, updatePolyline as p, createCircle as q, removeChilds as r, updateCircle as s, textScale as t, updateText as u, createLineLabel as v, windowSize as w, axisConvertX as x, getTotalLength as y, getNearest as z };
